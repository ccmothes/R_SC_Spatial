# set some standard parameter for the documents.
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
# load required libraries
library(sf)
library(raster)
library(dplyr)
library(tmap)
## change this to the directory where your folder is stored
baseDir <- "D:/R_SC_Spatial/intermediateGeospatialR"
# grab all counts images
images <- list.files(path = paste0(baseDir,"/data/nightLights"),
pattern = "_counts.tif",
full.names = TRUE)
images
## change this to the directory where your folder is stored
baseDir <- "~/Desktop/R_SC_Spatial/intermediateGeospatialR"
# grab all counts images
images <- list.files(path = paste0(baseDir,"/data/nightLights"),
pattern = "_counts.tif",
full.names = TRUE)
# grab all counts images
images <- list.files(path = paste0(baseDir,"/data/nightLights"),
pattern = "_counts.tif",
full.names = TRUE)
images
# read in image
temp1 <- raster::raster(images[1])
temp1
# grab a radiance image
allImages <- list.files(path = paste0(baseDir,"/data/nightLights"),
pattern = ".tif",
full.names = TRUE,
recursive = TRUE)
# print to find an image from a county
allImages[1:10]
# read in county processed image
r1 <- raster::raster(allImages[5])
# crop the raster
temp2 <- temp1 %>%
raster::crop(r1)
# pull attributes and view
temp2
qtm(temp2)
# grab the values of the raster object
vals <- raster::values(temp2)
# summary() base R
summary(vals)
# plot a histogram
hist(vals)
# create a mask object
mask <- r1
# reassing all positive values to 1
mask[mask >= 0, ] <- 1
# set any value not equal to 1 as NA
mask[mask != 1, ] <- NA
# multiple raster to apply the mask
counts <- temp2 * mask
qtm(counts)
vals2 <- raster::values(counts)
summary(vals2)
hist(vals2)
# pull total number of observations
vals_noNA <- vals2[!is.na(vals2)]
total <- length(vals_noNA)
# determine sequence of interest
seq1 <- seq(min(vals_noNA),max(vals_noNA), by =1 )
getArea <- function(values,  index){
### values: vector of numerical features
### index: numerical value to filter on
# add na clause just to be safe
values <- values[!is.na(values)]
# get total
total <- length(values)
# get new values based on index
vals_new <- values[values >= index]
# calc average
ave <- 100*(length(vals_new)/ total)
return(ave)
}
getArea <- function(values,  index){
### values: vector of numerical features
### index: numerical value to filter on
# add na clause just to be safe
values <- values[!is.na(values)]
# get total
total <- length(values)
# get new values based on index
vals_new <- values[values >= index]
# calc average
ave <- 100*(length(vals_new)/ total)
return(ave)
}
# create a dataframe to store content
df <- data.frame(matrix(nrow = length(seq1), ncol = 2))
names(df) <- c("filter", "percent area")
# assign the filter element because we have it already
df$filter <- seq1
for(i in seq_along(seq1)){
# index column position using i, but define the filter value by seq1 feature
df$`percent area`[i] <- getArea(values = vals_noNA, index = seq1[i])
}
df
n = 1
for(i in seq1){
# index column position using i, but define the filter value by seq1 feature
df$`percent area`[n] <- getArea(values = vals_noNA, index = i)
n = n + 1
}
df
# create a dataframe to store content
df <- data.frame(matrix(nrow = length(seq1), ncol = 4))
### adding new columns for mean and median
names(df) <- c("filter", "percent area", "mean", "median")
# assign the filter element because we have it already
df$filter <- seq1
# Check to make sure the original feature we read in matches our month of interest
r1
temp1
## speculating on workflow
i <- "filter level"
## create a mask of the counts layer
counts[counts >= i, ] <- 1
radMeanAndMedian <- function(countRaster, radianceRaster, index){
## create a mask of the counts layer
countRaster[countRaster < index] <- NA
countRaster[countRaster >= index] <- 1
##  apply the mask to the radiance layer
rad1 <- radianceRaster * countRaster
## remove all NA values
rad_vals <- raster::values(rad1)
rad_vals <- rad_vals[!is.na(rad_vals)]
## create a vector to store outputs
values <- c()
## calculate mean and median
values[1] <- mean(rad_vals)
values[2] <- median(rad_vals)
return(values)
}
# define input parameters
count_rastula <- counts
rad_rast  <- raster::raster(allImages[5])
# determine sequence of filters
count_vals <- raster::values(count_rastula)
vals_noNA <- count_vals[!is.na(count_vals)]
seq1 <-seq(min(vals_noNA), max(vals_noNA), by = 1)
# loop over filter values
for(i in seq_along(seq1)){
# run the area function
df$`percent area`[i] <- getArea(values = vals_noNA, index = seq1[i])
# run the mean median function
meanMedian <- radMeanAndMedian(countRaster = count_rastula,
radianceRaster = rad_rast,
index = seq1[i])
# a vector is returned with mean and median values, index to assign it to the correct positions
df[i,3:4] <- meanMedian
}
df
# install and load package
# install.packages("plotly")
library(plotly)
### Plot a figure
p1 <- plot_ly()
p1
p2 <- p1 %>%
add_trace(x = df$filter, y = df$`percent area`,type = 'scatter')
p2
p3 <- p2%>%
add_trace(x=df$filter, y=df$`percent area`,type = 'scatter', line = list(dash = 'dash', shape= "spline"))
p3
p1 <- plot_ly() %>%
add_trace(x = df$filter, y = df$`percent area`,type = 'scatter', line = list(dash = 'dash', shape= "spline"))%>%
layout(xaxis = list(title = "Filter Level"),
yaxis = list(title = "Percentage of Coverage"))
p1
# mean plot
p2 <- plot_ly(x = df$filter, y = df$mean,type = 'scatter', line = list(dash = 'dash', shape= "spline")) %>%
layout(xaxis = list(title = "Filter Level"),
yaxis = list(title = "Mean"))
# median plot
p3 <- plot_ly() %>%
add_trace(x=df$filter, y=df$median,type = 'scatter', line = list(dash = 'dash', shape= "spline"))%>%
layout(xaxis = list(title = "Filter Level"),
yaxis = list(title = "Median"))
p2
p3
p <- plotly::subplot(p1,p2,p3, nrows = 3, shareX = TRUE, titleY = TRUE)
p
